local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MessagingService = game:GetService("MessagingService")
local TeleportService = game:GetService("TeleportService")

local MatchmakingRequest = ReplicatedStorage:WaitForChild("MatchmakingRequest")
local CancelMatchmakingRequest = ReplicatedStorage:WaitForChild("CancelMatchmakingRequest")

local PartyService = require(game.ServerScriptService:WaitForChild("PartyService"))

local PlaceId = game.PlaceId

-- Queue entries are either solos or groups; groups are not split
local QueueByMode = {
	["1v1"] = {},
	["2v2"] = {},
	["3v3"] = {}
}

local modeSizes = {
	["1v1"] = 2,
	["2v2"] = 4,
	["3v3"] = 6,
}

-- Track players who requested matchmaking locally (maps to group if any)
-- userId -> { mode = string, groupId = string|nil }
local localQueuedPlayers = {}

-- Topics
local topic = "MatchmakingQueueUpdate"
local matchTopic = "MatchmakingMatchFormed"

-- Helpers
local function isUserQueued(userId)
	return localQueuedPlayers[userId] ~= nil
end

local function findEntryContainingUser(queue, userId)
	for idx, entry in ipairs(queue) do
		if entry.kind == "solo" and entry.userId == userId then
			return idx, entry
		elseif entry.kind == "group" then
			for _, id in ipairs(entry.users) do
				if id == userId then
					return idx, entry
				end
			end
		end
	end
	return nil, nil
end

local function removeUserFromQueue(userId)
	local info = localQueuedPlayers[userId]
	if not info then return end
	local mode = info.mode
	local queue = QueueByMode[mode]
	local idx, entry = findEntryContainingUser(queue, userId)
	if not idx then
		localQueuedPlayers[userId] = nil
		return
	end

	if entry.kind == "solo" then
		table.remove(queue, idx)
		localQueuedPlayers[userId] = nil
	else
		-- group: remove the user from the group
		for i = #entry.users, 1, -1 do
			if entry.users[i] == userId then
				table.remove(entry.users, i)
				entry.size -= 1
				break
			end
		end
		localQueuedPlayers[userId] = nil
		if entry.size <= 0 then
			table.remove(queue, idx)
		end
	end

	-- Broadcast removal for cross-server sync
	pcall(function()
		MessagingService:PublishAsync(topic, {
			action = "remove_user",
			userId = userId,
			mode = mode,
		})
	end)
end

local function addSoloToQueue(player, mode)
	if not QueueByMode[mode] then return end
	if isUserQueued(player.UserId) then return end

	table.insert(QueueByMode[mode], { kind = "solo", userId = player.UserId, size = 1 })
	localQueuedPlayers[player.UserId] = { mode = mode }

	pcall(function()
		MessagingService:PublishAsync(topic, { action = "add_solo", userId = player.UserId, mode = mode })
	end)
end

local function addGroupToQueue(users, mode, groupId)
	if not QueueByMode[mode] then return end
	-- Prevent duplicates if any user already queued
	for _, uid in ipairs(users) do
		if isUserQueued(uid) then return end
	end

	local entry = { kind = "group", users = table.clone(users), groupId = tostring(groupId), size = #users }
	table.insert(QueueByMode[mode], entry)
	for _, uid in ipairs(users) do
		localQueuedPlayers[uid] = { mode = mode, groupId = entry.groupId }
	end

	pcall(function()
		MessagingService:PublishAsync(topic, { action = "add_group", users = users, groupId = entry.groupId, mode = mode })
	end)
end

-- Try to form a match of exact required size without splitting groups (first-fit)
local function tryMatchmaking(mode)
	local queue = QueueByMode[mode]
	local requiredSize = modeSizes[mode]
	if #queue == 0 then return end

	for startIdx = 1, #queue do
		local selected = {}
		local total = 0
		for i = startIdx, #queue do
			local e = queue[i]
			if total + e.size <= requiredSize then
				table.insert(selected, i)
				total += e.size
				if total == requiredSize then
					-- Build user list
					local users = {}
					local groupsInfo = {}
					for _, idx in ipairs(selected) do
						local entry = queue[idx]
						if entry.kind == "solo" then
							table.insert(users, entry.userId)
							table.insert(groupsInfo, { kind = "solo", users = { entry.userId } })
						else
							for _, id in ipairs(entry.users) do table.insert(users, id) end
							table.insert(groupsInfo, { kind = "group", groupId = entry.groupId, users = table.clone(entry.users) })
						end
					end

					-- Remove selected entries from queue and clear local map
					-- Remove from highest index to lowest to keep indices valid
					table.sort(selected, function(a,b) return a>b end)
					for _, idxToRemove in ipairs(selected) do
						local entry = table.remove(queue, idxToRemove)
						if entry.kind == "solo" then
							localQueuedPlayers[entry.userId] = nil
						else
							for _, id in ipairs(entry.users) do localQueuedPlayers[id] = nil end
						end
					end

					-- Publish match so all servers teleport their local subset
					local reservedServerCode = TeleportService:ReserveServer(PlaceId)
					pcall(function()
						MessagingService:PublishAsync(matchTopic, {
							action = "match",
							mode = mode,
							code = reservedServerCode,
							users = users,
							teleportData = { mode = mode, groups = groupsInfo },
						})
					end)
					return
				end
			end
		end
	end
end

-- Cross-server sync
MessagingService:SubscribeAsync(topic, function(message)
	local data = message.Data
	local action = data.action
	local mode = data.mode
	if not QueueByMode[mode] then return end

	if action == "add_solo" then
		-- Avoid duplicates
		for _, entry in ipairs(QueueByMode[mode]) do
			if entry.kind == "solo" and entry.userId == data.userId then return end
		end
		table.insert(QueueByMode[mode], { kind = "solo", userId = data.userId, size = 1 })
	elseif action == "add_group" then
		-- Avoid duplicates (any user from group already present?)
		for _, uid in ipairs(data.users or {}) do
			for _, entry in ipairs(QueueByMode[mode]) do
				if (entry.kind == "solo" and entry.userId == uid) then return end
				if entry.kind == "group" then
					for _, id in ipairs(entry.users) do if id == uid then return end end
				end
			end
		end
		table.insert(QueueByMode[mode], { kind = "group", users = table.clone(data.users or {}), groupId = tostring(data.groupId), size = #(data.users or {}) })
	elseif action == "remove_user" then
		-- Remove a single user from any entry
		local queue = QueueByMode[mode]
		local idx, entry = findEntryContainingUser(queue, data.userId)
		if idx then
			if entry.kind == "solo" then
				table.remove(queue, idx)
			else
				for i = #entry.users, 1, -1 do
					if entry.users[i] == data.userId then
						table.remove(entry.users, i)
						entry.size -= 1
						break
					end
				end
				if entry.size <= 0 then table.remove(queue, idx) end
			end
		end
	end
end)

MessagingService:SubscribeAsync(matchTopic, function(message)
	local data = message.Data
	if data.action ~= "match" then return end

	local mode = data.mode
	local code = data.code
	local users = data.users or {}

	-- Remove these users locally if they exist
	local queue = QueueByMode[mode]
	if queue then
		for _, uid in ipairs(users) do
			local idx = select(1, findEntryContainingUser(queue, uid))
			if idx then
				local entry = queue[idx]
				if entry.kind == "solo" then
					table.remove(queue, idx)
				else
					for i = #entry.users, 1, -1 do
						if entry.users[i] == uid then table.remove(entry.users, i) entry.size -= 1 break end
					end
					if entry.size <= 0 then table.remove(queue, idx) end
				end
			end
			localQueuedPlayers[uid] = nil
		end
	end

	-- Teleport any users present on this server
	local playersHere = {}
	for _, uid in ipairs(users) do
		local p = Players:GetPlayerByUserId(uid)
		if p then table.insert(playersHere, p) end
	end
	if #playersHere > 0 then
		pcall(function()
			TeleportService:TeleportToPrivateServer(PlaceId, code, playersHere, nil, data.teleportData)
		end)
	end
end)

-- Requests
MatchmakingRequest.OnServerEvent:Connect(function(player, data)
	local mode = data.mode
	if not QueueByMode[mode] then
		warn("Invalid mode:", mode)
		return
	end

	-- Determine party and enforce leader-only
	local party = PartyService:GetParty(player)
	if party then
		if party.Leader ~= player then
			-- Not leader: ignore request
			return
		end
		-- Build userId list for the whole party
		local users = {}
		for _, member in ipairs(party.Members) do table.insert(users, member.UserId) end
		addGroupToQueue(users, mode, party.Leader.UserId)
	else
		-- No party: treat as solo (they are implicitly their own leader)
		addSoloToQueue(player, mode)
	end

	tryMatchmaking(mode)
end)

CancelMatchmakingRequest.OnServerEvent:Connect(function(player)
	-- Remove the player (and potentially shrink their group)
	removeUserFromQueue(player.UserId)
end)

Players.PlayerRemoving:Connect(function(player)
	removeUserFromQueue(player.UserId)
end)
