local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MessagingService = game:GetService("MessagingService")
local TeleportService = game:GetService("TeleportService")

local MatchmakingRequest = ReplicatedStorage:WaitForChild("MatchmakingRequest")
local CancelMatchmakingRequest = ReplicatedStorage:WaitForChild("CancelMatchmakingRequest")

local PlaceId = game.PlaceId

local QueueByMode = {
	["1v1"] = {},
	["2v2"] = {},
	["3v3"] = {}
}

local modeSizes = {
	["1v1"] = 2,
	["2v2"] = 4,
	["3v3"] = 6,
}

-- Track players who requested matchmaking locally
local localQueuedPlayers = {}

-- Topic to send and receive queue updates between servers
local topic = "MatchmakingQueueUpdate"

-- Adds a player to local queue and broadcasts update
local function addPlayerToQueue(player, mode)
	if not QueueByMode[mode] then return end

	-- Prevent duplicates
	if localQueuedPlayers[player.UserId] then
		-- already queued
		return
	end

	table.insert(QueueByMode[mode], player.UserId)
	localQueuedPlayers[player.UserId] = mode

	-- Broadcast update to all servers (pcall for safety)
	pcall(function()
		MessagingService:PublishAsync(topic, {
			action = "add",
			userId = player.UserId,
			mode = mode,
		})
	end)
end

-- Removes a player locally and broadcasts update
local function removePlayerFromQueue(userId)
	local mode = localQueuedPlayers[userId]
	if not mode then return end

	-- Remove from mode queue
	local queue = QueueByMode[mode]
	for i = #queue, 1, -1 do
		if queue[i] == userId then
			table.remove(queue, i)
			break
		end
	end

	localQueuedPlayers[userId] = nil

	-- Broadcast removal (pcall for safety)
	pcall(function()
		MessagingService:PublishAsync(topic, {
			action = "remove",
			userId = userId,
			mode = mode,
		})
	end)
end

-- Attempt to form matches when enough players locally queued (present in this server)
local function tryMatchmaking(mode)
	local queue = QueueByMode[mode]
	local requiredSize = modeSizes[mode]

	-- Collect up to requiredSize players that are actually present on this server
	local presentUserIds = {}
	for _, userId in ipairs(queue) do
		if Players:GetPlayerByUserId(userId) then
			table.insert(presentUserIds, userId)
			if #presentUserIds == requiredSize then
				break
			end
		end
	end

	if #presentUserIds < requiredSize then
		return
	end

	-- Remove only the selected, present players from the queue
	for _, selectedUserId in ipairs(presentUserIds) do
		for i = #queue, 1, -1 do
			if queue[i] == selectedUserId then
				table.remove(queue, i)
				break
			end
		end
		localQueuedPlayers[selectedUserId] = nil
	end

	-- Notify removal for all match players
	for _, userId in ipairs(presentUserIds) do
		pcall(function()
			MessagingService:PublishAsync(topic, {
				action = "remove",
				userId = userId,
				mode = mode,
			})
		end)
	end

	-- Reserve private server
	local reservedServerCode = TeleportService:ReserveServer(PlaceId)

	-- Create player list for teleport
	local playersForTeleport = {}
	for _, userId in ipairs(presentUserIds) do
		local player = Players:GetPlayerByUserId(userId)
		if player then
			table.insert(playersForTeleport, player)
		end
	end

	if #playersForTeleport == requiredSize then
		-- Teleport grouped players to reserved server in a single call
		local ok, err = pcall(function()
			TeleportService:TeleportToPrivateServer(PlaceId, reservedServerCode, playersForTeleport)
		end)
		if not ok then
			warn("Teleport failed for mode", mode, err)
			-- On failure, re-add players to the front of the queue
			for _, player in ipairs(playersForTeleport) do
				local userId = player.UserId
				table.insert(queue, 1, userId)
				localQueuedPlayers[userId] = mode
				pcall(function()
					MessagingService:PublishAsync(topic, { action = "add", userId = userId, mode = mode })
				end)
			end
		else
			print("Match created for mode", mode)
		end
	end
end

-- Handle incoming messages from other servers
MessagingService:SubscribeAsync(topic, function(message)
	local data = message.Data
	if data.action == "add" then
		-- Add userId to queues remotely (do not mark as localQueued)
		local mode = data.mode
		local userId = data.userId
		if QueueByMode[mode] then
			-- Avoid duplicates in the raw queue
			local alreadyInQueue = false
			for _, id in ipairs(QueueByMode[mode]) do
				if id == userId then
					alreadyInQueue = true
					break
				end
			end
			if not alreadyInQueue then
				table.insert(QueueByMode[mode], userId)
			end
			-- Attempt matchmaking using locally present players
			tryMatchmaking(mode)
		end
	elseif data.action == "remove" then
		-- Remove userId from queue remotely
		local mode = data.mode
		local userId = data.userId
		local queue = QueueByMode[mode]

		for i = #queue, 1, -1 do
			if queue[i] == userId then
				table.remove(queue, i)
				break
			end
		end

		localQueuedPlayers[userId] = nil
	end
end)

-- Player requests matchmaking
MatchmakingRequest.OnServerEvent:Connect(function(player, data)
	local mode = data.mode
	if not QueueByMode[mode] then
		warn("Invalid mode:", mode)
		return
	end

	addPlayerToQueue(player, mode)
	tryMatchmaking(mode)
end)

-- Player cancels matchmaking
CancelMatchmakingRequest.OnServerEvent:Connect(function(player)
	removePlayerFromQueue(player.UserId)
end)

-- Remove players from queue on leave
Players.PlayerRemoving:Connect(function(player)
	removePlayerFromQueue(player.UserId)
end)
