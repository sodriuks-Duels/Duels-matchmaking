local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MessagingService = game:GetService("MessagingService")
local TeleportService = game:GetService("TeleportService")

local MatchmakingRequest = ReplicatedStorage:WaitForChild("MatchmakingRequest")
local CancelMatchmakingRequest = ReplicatedStorage:WaitForChild("CancelMatchmakingRequest")

local PlaceId = game.PlaceId

local QueueByMode = {
	["1v1"] = {},
	["2v2"] = {},
	["3v3"] = {}
}

local modeSizes = {
	["1v1"] = 2,
	["2v2"] = 4,
	["3v3"] = 6,
}

-- Track players who requested matchmaking locally
local localQueuedPlayers = {}

-- Topic to send and receive queue updates between servers
local topic = "MatchmakingQueueUpdate"
local matchTopic = "MatchmakingMatchFormed"

-- Adds a player to local queue and broadcasts update
local function addPlayerToQueue(player, mode)
	if not QueueByMode[mode] then return end

	-- Prevent duplicates
	if localQueuedPlayers[player.UserId] then
		-- already queued
		return
	end

	table.insert(QueueByMode[mode], player.UserId)
	localQueuedPlayers[player.UserId] = mode

	-- Broadcast update to all servers (pcall for safety)
	pcall(function()
		MessagingService:PublishAsync(topic, {
			action = "add",
			userId = player.UserId,
			mode = mode,
		})
	end)
end

-- Removes a player locally and broadcasts update
local function removePlayerFromQueue(userId)
	local mode = localQueuedPlayers[userId]
	if not mode then return end

	-- Remove from mode queue
	local queue = QueueByMode[mode]
	for i = #queue, 1, -1 do
		if queue[i] == userId then
			table.remove(queue, i)
			break
		end
	end

	localQueuedPlayers[userId] = nil

	-- Broadcast removal (pcall for safety)
	pcall(function()
		MessagingService:PublishAsync(topic, {
			action = "remove",
			userId = userId,
			mode = mode,
		})
	end)
end

-- Attempt to form matches using global queue (cross-server)
local function tryMatchmaking(mode)
	local queue = QueueByMode[mode]
	local requiredSize = modeSizes[mode]

	if #queue < requiredSize then
		return
	end

	-- Select first N userIds from the aggregated queue
	local selectedUserIds = {}
	for i = 1, requiredSize do
		table.insert(selectedUserIds, queue[i])
	end

	-- Remove selected userIds from local queue and local map
	for _, selectedUserId in ipairs(selectedUserIds) do
		for i = #queue, 1, -1 do
			if queue[i] == selectedUserId then
				table.remove(queue, i)
				break
			end
		end
		localQueuedPlayers[selectedUserId] = nil
	end

	-- Reserve private server and publish match so every server teleports its local subset
	local reservedServerCode = TeleportService:ReserveServer(PlaceId)
	pcall(function()
		MessagingService:PublishAsync(matchTopic, {
			action = "match",
			mode = mode,
			code = reservedServerCode,
			users = selectedUserIds,
		})
	end)
end

-- Handle incoming messages from other servers
MessagingService:SubscribeAsync(topic, function(message)
	local data = message.Data
	if data.action == "add" then
		-- Add userId to queues remotely (do not mark as localQueued)
		local mode = data.mode
		local userId = data.userId
		if QueueByMode[mode] then
			-- Avoid duplicates in the raw queue
			local alreadyInQueue = false
			for _, id in ipairs(QueueByMode[mode]) do
				if id == userId then
					alreadyInQueue = true
					break
				end
			end
			if not alreadyInQueue then
				table.insert(QueueByMode[mode], userId)
			end
			-- Attempt matchmaking using aggregated queue (cross-server)
			tryMatchmaking(mode)
		end
	elseif data.action == "remove" then
		-- Remove userId from queue remotely
		local mode = data.mode
		local userId = data.userId
		local queue = QueueByMode[mode]

		for i = #queue, 1, -1 do
			if queue[i] == userId then
				table.remove(queue, i)
				break
			end
		end

		localQueuedPlayers[userId] = nil
	end
end)

-- Receive match formed announcements; teleport local subset to the same private server
MessagingService:SubscribeAsync(matchTopic, function(message)
	local data = message.Data
	if data.action ~= "match" then return end

	local mode = data.mode
	local code = data.code
	local users = data.users or {}

	-- Remove these users from local queue/state, then teleport any that are present here
	local queue = QueueByMode[mode]
	if queue then
		for _, userId in ipairs(users) do
			for i = #queue, 1, -1 do
				if queue[i] == userId then
					table.remove(queue, i)
					break
				end
			end
			localQueuedPlayers[userId] = nil
		end
	end

	local playersHere = {}
	for _, userId in ipairs(users) do
		local p = Players:GetPlayerByUserId(userId)
		if p then table.insert(playersHere, p) end
	end
	if #playersHere > 0 then
		pcall(function()
			TeleportService:TeleportToPrivateServer(PlaceId, code, playersHere)
		end)
	end
end)

-- Player requests matchmaking
MatchmakingRequest.OnServerEvent:Connect(function(player, data)
	local mode = data.mode
	if not QueueByMode[mode] then
		warn("Invalid mode:", mode)
		return
	end

	addPlayerToQueue(player, mode)
	tryMatchmaking(mode)
end)

-- Player cancels matchmaking
CancelMatchmakingRequest.OnServerEvent:Connect(function(player)
	removePlayerFromQueue(player.UserId)
end)

-- Remove players from queue on leave
Players.PlayerRemoving:Connect(function(player)
	removePlayerFromQueue(player.UserId)
end)
